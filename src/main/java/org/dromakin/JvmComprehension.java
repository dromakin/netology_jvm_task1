/*
 * File:     JvmComprehension
 * Package:  org.dromakin
 * Project:  netology_jvm_task1
 *
 * Created by dromakin as 04.02.2023
 *
 * author - dromakin
 * maintainer - dromakin
 * version - 2023.02.04
 * copyright - Echelon Inc. 2023
 */

package org.dromakin;

public class JvmComprehension {
    /*
    Анализ кода
    Запуск подсистемы загрузчиков классов
    Класс JvmComprehension (с константами, методами и т.д.) загружается через Class Loading и получение информации об этом классе в памяти
    Подсистема загрузчиков классов использует 3 стандартных загрузчиков классов (по этапно):
    1. Application ClassLoader ->
    2. Platform ClassLoader ->
    3. Bootstrap ClassLoader ->
    4. Пользовательские ClassLoader ->
    -> Поиск класса:
    1. Если нашел, то загрузил
    2. Генерирование исключения: java.lang.ClassNotFoundException

    Класс JvmComprehension загружается в JVM с помощью classloader.
    Во время этого процесса JVM проверяет байт-код класса.

    JVM инициализирует класс, т.е. выделяет память для переменных класса, устанавливает их начальные значения и подготавливает класс к использованию.
    Этот процесс выполняется один раз для каждого класса и происходит перед выполнением любого метода в классе.

    JVM вызывает основной метод класса, создавая новый фрейм метода в стеке вызовов для хранения переменных и промежуточных значений, используемых во время выполнения метода.

    Метапространство JVM - это область памяти, в которой хранятся метаданные класса и связанная с классом информация, такая как определения классов и методов.
    Метапространство выделяется в собственной куче и отделено от Java-кучи, в которой хранятся объекты.
    Размер метапространства динамически изменяется JVM, и его размер ограничен объемом памяти, доступной в системе.
    В отличие от традиционной постоянной генерации (PermGen) в более ранних версиях JVM, метапространство не имеет фиксированного размера и может расширяться по мере необходимости.
    Когда класс загружается в JVM, определение класса и метаданные сохраняются в метапространстве, что позволяет JVM быстро получать к нему доступ во время выполнения.
    Эта область имеет динамический размер и не имеет фиксированного ограничения по размеру, в отличие от кучи.
    Класс "JvmComprehension" будет занимать часть памяти в метапространстве в JVM.
     */

    public static void main(String[] args) {
        int i = 1;                      // 1 - В стеке создается переменная i типа int, которой присваивается значение 1.
        // Значение хранится в стеке, который представляет собой область памяти, содержащую локальные переменные, параметры и промежуточные результаты вызовов методов.

        Object o = new Object();        // 2 - Объект типа Object создается в куче, и ссылка на него присваивается переменной o.
        // Объект хранится в куче, которая представляет собой область памяти, содержащую все объекты, созданные в программе.

        Integer ii = 2;                 // 3 - Объект типа Integer со значением 2 создается в куче, и ссылка на него присваивается переменной ii. Как и o, объект Integer хранится в куче.
        printAll(o, i, ii);             // 4 - Вызывается метод printAll, передающий o, i и ii в качестве аргументов.
                                        // 4 - В стеке создается новый фрейм метода для хранения переменных и промежуточных значений, используемых в этом методе.
        // Когда метод printAll возвращается, фрейм его метода извлекается из стека, то он подходит к этапу сборки мусора.
        System.out.println("finished"); // 7 - Строка "finished" выводится на консоль.
        // Сборщик мусора JVM периодически запускается, освобождая память, занятую объектами, которые больше недоступны, и освобождая ее для повторного использования.
        // Уничтожение переменной (очистка ресурсов) с помощью garbage collector: i, o, ii
        // Когда основной метод возвращается, его фрейм метода извлекается из стека, и JVM завершает работу, завершая программу.
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5 - В строке 5 создается целочисленный объект с именем uselessVar, которому присваивается значение 700. Этот объект также хранится в куче.
        System.out.println(o.toString() + i + ii);  // 6 - Метод toString вызывается для объекта, на который ссылается o.
        // Строковое представление получается путем вызова toString на o, и значения i и ii автоматически распаковываются в int перед их объединением.
        // Уничтожение uselessVar с помощью garbage collector
    }
}
